<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【实验4】traps-lab</title>
      <link href="/2024/07/04/trapslab/"/>
      <url>/2024/07/04/trapslab/</url>
      
        <content type="html"><![CDATA[<h1 id="【实验4】traps-lab"><a href="#【实验4】traps-lab" class="headerlink" title="【实验4】traps-lab"></a>【实验4】traps-lab</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><h3 id="1-哪些寄存器包含函数的参数？例如，哪个寄存器在-main-对-printf-的调用中保存-13？"><a href="#1-哪些寄存器包含函数的参数？例如，哪个寄存器在-main-对-printf-的调用中保存-13？" class="headerlink" title="1.哪些寄存器包含函数的参数？例如，哪个寄存器在 main 对 printf 的调用中保存 13？"></a>1.哪些寄存器包含函数的参数？例如，哪个寄存器在 main 对 printf 的调用中保存 13？</h3><p>a0-a7寄存器包含函数的参数。a2寄存器在main对printf的调用中保存13</p><img src="file:///C:/Users/yujiz/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"  /><p><img src="file:///C:/Users/yujiz/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reg    | name  | saver  | description</span><br><span class="line">-------+-------+--------+------------</span><br><span class="line">x0     | zero  |        | hardwired zero</span><br><span class="line">x1     | ra    | caller | return address</span><br><span class="line">x2     | sp    | callee | stack pointer</span><br><span class="line">x3     | gp    |        | global pointer</span><br><span class="line">x4     | tp    |        | thread pointer</span><br><span class="line">x5-7   | t0-2  | caller | temporary registers</span><br><span class="line">x8     | s0/fp | callee | saved register / frame pointer</span><br><span class="line">x9     | s1    | callee | saved register</span><br><span class="line">x10-11 | a0-1  | caller | function arguments / return values</span><br><span class="line">x12-17 | a2-7  | caller | function arguments</span><br><span class="line">x18-27 | s2-11 | callee | saved registers</span><br><span class="line">x28-31 | t3-6  | caller | temporary registers</span><br><span class="line">pc     |       |        | program counter</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">How are arguments passed?</span><br><span class="line">    a0, a1, ..., a7, rest on stack</span><br><span class="line">How are values returned?</span><br><span class="line">    a0, a1</span><br></pre></td></tr></table></figure><h3 id="2-Where-is-the-call-to-function-f-in-the-assembly-code-for-main-Where-is-the-call-to-g-Hint-the-compiler-may-inline-functions"><a href="#2-Where-is-the-call-to-function-f-in-the-assembly-code-for-main-Where-is-the-call-to-g-Hint-the-compiler-may-inline-functions" class="headerlink" title="2.Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)"></a>2.Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</h3><p>​main 的汇编代码没有调用 f 和 g 函数。编译器可以内联函数。</p><h3 id="3-At-what-address-is-the-function-printf-located"><a href="#3-At-what-address-is-the-function-printf-located" class="headerlink" title="3.At what address is the function printf located?"></a>3.At what address is the function printf located?</h3><p>0x614</p><p><img src="file:///C:/Users/yujiz/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"></p><h3 id="4-What-value-is-in-the-register-ra-just-after-the-jalr-to-printf-in-main"><a href="#4-What-value-is-in-the-register-ra-just-after-the-jalr-to-printf-in-main" class="headerlink" title="4.What value is in the register ra just after the jalr to printf in main?"></a>4.What value is in the register ra just after the jalr to printf in main?</h3><p>0x38</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span>:  <span class="number">00000097</span>       auipc   ra,<span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="number">34</span>:  <span class="number">612080e7</span>       jalr <span class="number">1554</span>(ra) # <span class="number">642</span> &lt;printf&gt;</span><br></pre></td></tr></table></figure><pre><code>      auipc就是把一个数左移12位，后再加上pc值</code></pre><p>​ <code>JALR rd，offset(rs1)</code></p><p>​jalr该指令将PC设置为rs1寄存器中的值加上符号位扩展的偏移量，把计算出地址的最低有效位设为0，并将原PC + 4的值写入rd寄存器。如果不需要目的寄存器，可以将rd设置为x0。如果只有offset(ra)，把pc+4存入ra</p><h3 id="5-输出是什幺？输出取决于-RISC-V-是小端这一事实。如果-RISC-V-是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616"><a href="#5-输出是什幺？输出取决于-RISC-V-是小端这一事实。如果-RISC-V-是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616" class="headerlink" title="5.输出是什幺？输出取决于 RISC-V 是小端这一事实。如果 RISC-V 是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616"></a>5.输出是什幺？输出取决于 RISC-V 是小端这一事实。如果 RISC-V 是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616</h3><p>​<a href="https://cpp.sh/?source=%23include+%3Cstdio.h%3E%0D%0Aint+main()%7B++%0D%0A++++unsigned+int+i+=+0x00646c72;%0D%0Aprintf(%22H%25x+Wo%25s%22,+57616,+&i);%0D%0A++++return+0;%7D">代码</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/yujiz/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img"></p><p>​57616 十六进制为 e110。 大端和小端不改变真正的值的大小，所以 57616 始终打印为e110 。</p><p>​在小端处理器中，数据高字节存储在内存的高位，从内存低位，也就是低字节开始读取，0x00646c72为rld。在大端处理器中，dlr。大端时，i 的值应该为0x726c64。</p><h3 id="6-In-the-following-code-what-is-going-to-be-printed-after-note-the-answer-is-not-a-specific-value-Why-does-this-happen-‘y-’"><a href="#6-In-the-following-code-what-is-going-to-be-printed-after-note-the-answer-is-not-a-specific-value-Why-does-this-happen-‘y-’" class="headerlink" title="6.In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? ‘y&#x3D;’"></a>6.In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? ‘y&#x3D;’</h3><p>​ <code>printf(&quot;x=%d y=%d&quot;, 3);</code>[代码](<a href="https://cpp.sh/?source=//+Example+program">https://cpp.sh/?source=%2F%2F+Example+program</a> %23include+ int+main() { ++printf(“x%3D%d+y%3D%d”%2C+3)%3B return+0%3B })</p><p>​ <em>x&#x3D;3 y&#x3D;0</em></p><p>​ prinf 少传了一个参数，会从参数传递寄存器中读取一个不确定的值，‘y&#x3D;’ 后面的值不能确定。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>对于调试来说，进行回溯通常很有用：在发生错误的位置上方堆栈上的函数调用列表。为了帮助进行回溯，编译器会生成<strong>机器代码</strong>，该代码在堆栈上维护与当前调用链中每个函数相对应的堆栈帧。每个<strong>堆栈帧</strong>都包含<strong>返回地址</strong>和指向调用者堆栈帧的“<strong>帧指针</strong>”。寄存器 <strong>s0</strong>包含指向当前堆栈帧的指针（它实际上指向堆栈上保存的返回地址的地址加 8）。您的回溯应该使用帧指针遍历堆栈并在每个堆栈帧中打印保存的返回地址。</p><p>在riscv.h中加入r_fp()函数来阅读s0</p><p>请注意，返回地址位于堆栈帧的帧指针的固定偏移量 （-8） 处，保存的帧指针位于距帧指针的固定偏移量 （-16） 处</p><p>fp帧指针，sp栈指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack:</span><br><span class="line">      |   | local variables |</span><br><span class="line">      |   |       ...       | &lt;-+</span><br><span class="line">      |   +-----------------+   |</span><br><span class="line">      |   | return address  |   |</span><br><span class="line">      +------ previous fp   |   |</span><br><span class="line">          | saved registers |   |</span><br><span class="line">          | local variables |   |</span><br><span class="line">  $fp --&gt; |       ...       |   |</span><br><span class="line">          +-----------------+   |</span><br><span class="line">          | return address  |   |</span><br><span class="line">          |   previous fp ------+</span><br><span class="line">          | saved registers |</span><br><span class="line">  $sp --&gt; | local variables |</span><br><span class="line">          +-----------------+</span><br></pre></td></tr></table></figure><p>需要一种方法来识别它已经看到了最后一个堆栈帧，并且应该停止。一个有用的事实是，为每个内核堆栈分配的内存由单个页面对齐的页面组成，因此给定堆栈的所有堆栈帧都在同一页面上。可以使用 PGROUNDDOWN（fp）来标识帧指针引用的页面。</p><p>在kernel&#x2F;printf.c中加入一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp_address = r_fp();</span><br><span class="line">  <span class="keyword">while</span>(fp_address != PGROUNDDOWN(fp_address)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp_address<span class="number">-8</span>));</span><br><span class="line">    fp_address = *(uint64*)(fp_address - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>在本练习中，您将向 xv6 添加一项功能，该功能会在进程使用 CPU 时间时定期发出警报。<br>实现用户级中断&#x2F;故障处理进程的原始形式;例如，您可以使用类似的东西来处理应用进程中的页面错误。如果通过 alarmtest 和“usertests -q”，则您的解决方案是正确的。</p><p>您应该添加一个新的 sigalarm（interval， handler） 系统调用。<br>如果应用进程调用 sigalarm（n， fn），则在进程消耗的 CPU 时间每 n 个“滴答”后，内核应调用应用进程函数 fn。<br>当 fn 返回时，应用进程应从中断的地方继续。刻度是 xv6 中相当任意的时间单位，由硬件计时器生成中断的频率决定。如果应用进程调用 sigalarm（0， 0），内核应停止生成周期性警告调用。</p><p>当使用 trap 方式陷入内核的时候，会执行 <code>kernel/trampoline.S</code> 中的 <code>uservec</code> ：<br>save user a0 in sscratch so a0 can be used to get at TRAPFRAME.<br>save the user registers in TRAPFRAME<br>jump to usertrap() in trap.c , which does not return：<br>①检测scause，为8的话去syscall，<code>p-&gt;trapframe-&gt;epc += 4;</code>(sepc points to the ecall instruction, but we want to return to the next instruction.)<br>②give up the CPU if this is a timer interrupt.<br> <code>if(which_dev == 2)yield();</code><br> <code>usertrapret();</code> (also in trap.c):<br>send syscalls, interrupts, and exceptions to uservec in trampoline.S<br>set up trapframe values that uservec will need when the process next traps into the kernel.<br>set up the registers that trampoline.S’s sret will use to get to user space.<br>jump to userret in trampoline.S  </p><p>在sysproc.c中加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">proc</span> =</span> myproc();</span><br><span class="line">  *proc-&gt;trapframe = proc-&gt;saved_trapframe;</span><br><span class="line">  proc-&gt;have_return = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> proc-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler_va;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;ticks);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;handler_va);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">proc</span> =</span> myproc();</span><br><span class="line">  proc-&gt;alarm_interval = ticks;</span><br><span class="line">  proc-&gt;handler_va = handler_va;</span><br><span class="line">  proc-&gt;have_return = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在trap.c中修改usertrap():(上面提到过的代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;alarm_interval &amp;&amp; proc-&gt;have_return) &#123;</span><br><span class="line">    <span class="keyword">if</span> (++proc-&gt;passed_ticks == <span class="number">2</span>) &#123;</span><br><span class="line">      proc-&gt;saved_trapframe = *p-&gt;trapframe;</span><br><span class="line">      proc-&gt;trapframe-&gt;epc = proc-&gt;handler_va;</span><br><span class="line">      proc-&gt;passed_ticks = <span class="number">0</span>;</span><br><span class="line">      proc-&gt;have_return = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【实验5】Copy-on-Write</title>
      <link href="/2024/07/04/%E5%AE%9E%E9%AA%8C5/"/>
      <url>/2024/07/04/%E5%AE%9E%E9%AA%8C5/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab5-Copy-on-Write-Fork-for-xv6"><a href="#Lab5-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab5: Copy-on-Write Fork for xv6"></a>Lab5: Copy-on-Write Fork for xv6</h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>问题：xv6 中的 fork() 系统调用会将父进程的所有用户空间内存复制到子进程中。如果父进程很大，拷贝可能需要很长时间。更糟糕的是，这些工作通常会被浪费掉：fork() 之后，子进程通常会执行 exec()，丢弃复制的内存，通常不会使用其中的大部分。另一方面，如果父进程和子进程都使用了复制的页面，并且其中一个或两个都写入了该页面，那么复制就是真正需要的。</p><p>需要实现的：实现写入时拷贝（COW）fork() 的目的是推迟分配和拷贝物理内存页，直到实际需要时才拷贝（如果需要的话）。COW fork() creates just a pagetable for the child, with PTEs for user memory pointing to the parent’s physical pages. COW fork() 只为子进程创建一个分页表，其中的用户内存 PTE 指向父进程的物理页面。COW fork() 会将父进程和子进程中的所有用户 PTE 标记为只读。当任何一个进程试图写入这些 COW 页面时，CPU 都会强制产生一个页面故障。内核页面故障处理程序会检测到这种情况，为故障进程分配一页物理内存，将原始页面复制到新页面，并修改故障进程中的相关 PTE 以引用新页面，这次的 PTE 标记为可写。当页面故障处理程序返回时，用户进程将能写入其页面副本。</p><p>​COW fork() 在释放实现用户内存的物理页时比较麻烦。一个给定的物理页可能会被多个进程的页表引用，只有当最后一个引用消失时，才能释放该页。在 xv6 这样的简单内核中，这种管理相当简单明了，但在生产内核中却很难做到这一点。</p><p>这里有一个合理的攻击计划：</p><ol><li><p>修改 uvmcopy() 以将父代的物理页面映射到子代，而不是分配新的页面。对于设置了 PTE_W 的页面，清除子代和父代 PTE 中的 PTE_W。</p></li><li><p>修改 usertrap() 以识别页面故障。当原本可写的 COW 页面出现写页面故障时，使用 kalloc() 分配新页面，将旧页面复制到新页面，并将新页面安装到设置了 PTE_W 的 PTE 中。原本只读的页面（未映射 PTE_W，如文本段中的页面）应保持只读并在父进程和子进程之间共享；试图写入此类页面的进程应被杀死。</p></li><li><p>确保每个物理页面在最后一次 PTE 引用消失时被释放，而不是在此之前。一个很好的方法是为每个物理页保留一个 “引用计数”，即引用该页的用户页表的数量。在 kalloc() 分配页面时，将页面的引用计数设为 1。只有当页面的引用计数为零时，kfree() 才会将该页面放回空闲列表。将这些计数保存在一个固定大小的整数数组中也是可以的。你必须为如何索引数组和如何选择数组大小制定一个方案。例如，你可以用页面的物理地址除以 4096 作为数组的索引，并给数组一个元素数，该元素数等于 kalloc.c 中 kinit() 放在空闲列表上的任何页面的最高物理地址。</p></li><li><p>修改 copyout() 以在遇到 COW 页面时使用与页面故障相同的方案。</p></li></ol><p>一些提示：</p><ol><li>记录每个 PTE 是否是 COW 映射的方法可能很有用。为此，可以使用 RISC-V PTE 中的 RSW（为软件保留）位。</li><li>usertests -q 可以探索 cowtest 无法测试的情况，因此不要忘记检查两者是否都通过了所有测试。</li><li>在 kernel&#x2F;riscv.h 的末尾有一些有用的宏和页表标志定义。</li><li>如果发生 COW 页面错误且没有可用内存，则应杀死进程。</li></ol><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>在物理内存中，XV6中的Shell通常会有4个page，当调用fork时，基本上就是创建了4个新的page，并将父进程page的内容拷贝到4个新的子进程的page中。</p><img src="D:\download\image-20240517141853147-C8M-9_Nu.png" alt="image-20240517141853147-C8M-9_Nu" style="zoom:80%;" /><h3 id="在riscv-h中"><a href="#在riscv-h中" class="headerlink" title="在riscv.h中"></a>在riscv.h中</h3><p>RSW可以随意使用，加入标志位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><h3 id="在kalloc-c中："><a href="#在kalloc-c中：" class="headerlink" title="在kalloc.c中："></a>在kalloc.c中：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> page_refcnt[PHYSTOP/PGSIZE]; <span class="comment">// COW reference count. </span></span><br></pre></td></tr></table></figure><p>这里的<code>volatile</code>关键字用于确保对<code>page_refcnt</code>数组的每次访问都是独立的，不会被缓存。这样可以确保在并发环境下，对<code>page_refcnt</code>数组的访问是正确的。<code>volatile</code>关键字的作用是：当一个变量被声明为<code>volatile</code>时，编译器会确保对它的每次访问都会直接从内存中读取，而不是从缓存中读取。这可以确保对<code>page_refcnt</code>数组的每次访问都是独立的，不会被缓存。</p><h4 id="在kfree-函数中加入（用于计数减一）："><a href="#在kfree-函数中加入（用于计数减一）：" class="headerlink" title="在kfree()函数中加入（用于计数减一）："></a>在kfree()函数中加入（用于计数减一）：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(page_refcnt[(uint64)pa/PGSIZE]&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    page_refcnt[(uint64)pa/PGSIZE] -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(page_refcnt[(uint64)pa/PGSIZE]&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  ···</span><br></pre></td></tr></table></figure><h4 id="在kalloc-函数中："><a href="#在kalloc-函数中：" class="headerlink" title="在kalloc()函数中："></a>在kalloc()函数中：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_refcnt[(uint64)r/PGSIZE] = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><h3 id="在trap-c中："><a href="#在trap-c中：" class="headerlink" title="在trap.c中："></a>在trap.c中：</h3><p>加入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> page_refcnt[PHYSTOP/PGSIZE];</span><br></pre></td></tr></table></figure><h4 id="在usertrap-中："><a href="#在usertrap-中：" class="headerlink" title="在usertrap()中："></a>在usertrap()中：</h4><p>判断scause是8的话去syscall，然后判断是否有中断发生：<code>else if((which_dev = devintr()) != 0)</code></p><p><img src="C:\Users\yujiz\AppData\Roaming\Typora\typora-user-images\image-20240704160315495.png" alt="image-20240704160315495"></p><p>存储&#x2F;原子操作页故障（Store&#x2F;AMO page fault）：当用户进程尝试将数据写入一个只读页面时，会发生这种异常。在这种情况下，代码会检查页表项（pte）是否包含Copy-on-Write（COW）标志。如果包含，那么它会为该页面分配一个新的物理页面，将旧页面复制到新页面，并将页表项更改为可写状态。如果不包含COW标志，那么它会打印一条错误消息并终止进程。</p><ol><li>获取当前异常的虚拟地址（write_va）。</li><li>检查虚拟地址是否在最大虚拟地址（MAXVA）范围内。如果不在这个范围内，那么就跳转到unexpected_scause标签，表示这是一个意外的异常。</li><li>获取当前进程的页表（pagetable）。</li><li>使用walk函数在页表中查找虚拟地址对应的页表项（pte）。</li><li>检查页表项是否包含COW标志。如果包含COW标志，那么说明这个页面是一个COW页面。</li><li>为新的页面分配内存（mem）。</li><li>将原始页面的内容复制到新的内存中（memmove）。</li><li>将新的页面映射到页表中，并取消原始页面的映射（uvmunmap和kfree）。</li><li>如果映射新页面失败，那么释放分配的内存，并跳转到not_enough_physical_memory_error标签，表示没有足够的物理内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(r_scause()==<span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      uint64 write_va = r_stval();<span class="comment">//获取当前异常的虚拟地址（write_va）</span></span><br><span class="line">      <span class="keyword">if</span>(write_va&gt;=MAXVA) <span class="keyword">goto</span> unexpected_scause; <span class="comment">//检查虚拟地址是否在最大虚拟地址（MAXVA）范围内。如果不在这个范围内，那么就跳转到unexpected_scause标签，表示这是一个意外的异常</span></span><br><span class="line">      <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;<span class="comment">//获取当前进程的页表（pagetable）</span></span><br><span class="line">      <span class="type">pte_t</span> *pte = walk(pagetable, write_va, <span class="number">0</span>);<span class="comment">//使用walk函数在页表中查找虚拟地址对应的页表项（pte）</span></span><br><span class="line">      <span class="keyword">if</span>(*pte &amp; PTE_COW) <span class="comment">//这个页面是一个COW页面</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//为新的页面分配内存（mem）</span></span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">          not_enough_physical_memory_error:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Not enough physical memory when copy-on-write! pid=%d\n&quot;</span>, p-&gt;pid);</span><br><span class="line">          setkilled(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将原始页面的内容复制到新的内存中（memmove）</span></span><br><span class="line">        memmove(mem, (<span class="type">char</span>*)PTE2PA(*pte), PGSIZE);</span><br><span class="line"><span class="comment">//将新的页面映射到页表中，并取消原始页面的映射（uvmunmap和kfree）</span></span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        flags = (flags &amp; (~PTE_COW)) | PTE_W; <span class="comment">//标为可写，且不是COW页面</span></span><br><span class="line">        uvmunmap(pagetable, PGROUNDDOWN(write_va), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mappages(pagetable, PGROUNDDOWN(write_va), PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;<span class="comment">//检查是否能够成功将内存映射到指定的虚拟地址。映射成功后，将内存块的指针mem分配给指定的虚拟地址。如果映射失败，则释放内存块。</span></span><br><span class="line">          kfree(mem);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;This should never happen! The page SHOULD exist. mappages() won&#x27;t fail!!! \n&quot;</span>);</span><br><span class="line">          <span class="keyword">goto</span> not_enough_physical_memory_error;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//不是COW页面</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">goto</span> unexpected_scause;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      unexpected_scause:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      setkilled(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="在vm-c中："><a href="#在vm-c中：" class="headerlink" title="在vm.c中："></a>在vm.c中：</h3><p>一样先加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> page_refcnt[PHYSTOP/PGSIZE];</span><br></pre></td></tr></table></figure><h4 id="修改uvmcopy-函数："><a href="#修改uvmcopy-函数：" class="headerlink" title="修改uvmcopy()函数："></a>修改uvmcopy()函数：</h4><p>原先：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">  <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">    </span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);<span class="comment">//复制页面</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后：</p><p>既然我们使用了Copy-on-Write（COW）机制，就没有必要复制页面。我们将原始页映射到子进程的页表中，然后在父进程和子进程的页表项中，将PTE_W标志（写权限标志）设置为0，将自定义的PTE_COW标志（Copy-on-Write标志）设置为1。</p><p>这样，当子进程试图写入原始页时，系统会自动分配一个新的页，并将原始页的内容复制到新页中。同时，由于父进程和子进程的页表项中的PTE_W标志都为0，所以子进程无法修改原始页。这样，我们就实现了Copy-on-Write机制，从而减少了内存操作的次数，提高了系统性能。</p><ol><li>如果父页表项具有可写标志（PTE_W），则将其设置为新标志（PTE_COW）。</li><li>将原始页映射到子页表中，并设置新的标志。如果映射失败，则跳转到错误处理。</li><li>增加原始页的引用计数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (*pte &amp; PTE_W) *pte = (*pte ^ PTE_W) | PTE_COW; <span class="comment">//如果父页表项具有可写标志（PTE_W），则将其设置为新标志（PTE_COW）</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(new, i, PGSIZE, pa, PTE_FLAGS(*pte)) != <span class="number">0</span>) <span class="keyword">goto</span> err;<span class="comment">//将原始页映射到子页表中，并设置新的标志。如果映射失败，则跳转到错误处理。</span></span><br><span class="line">    page_refcnt[(uint64)pa / PGSIZE] += <span class="number">1</span>; <span class="comment">//增加原始页的引用计数。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="修改copyout函数："><a href="#修改copyout函数：" class="headerlink" title="修改copyout函数："></a>修改copyout函数：</h4><p>原先：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> || (*pte &amp; PTE_W) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>修改后：</p><p>它处理的是当遇到一个写保护（PTE_W）或COW（Copy-on-Write）标志被设置的页表项（pte）时的情况。</p><ol><li>首先，代码检查pte是否为0，或者PTE_V（页表项有效）和PTE_U（用户空间可访问）标志是否被设置。如果这些条件不满足，函数返回-1。</li><li>接下来，代码检查PTE_W（写保护）标志是否被设置，以及PTE_COW（Copy-on-Write）标志是否被设置。如果PTE_W标志没有被设置，且PTE_COW标志被设置，那么表示遇到了一个COW页。</li><li>对于COW页，代码首先尝试为新的页分配内存。如果内存分配失败，函数跳转到not_enough_physical_memory_error标签，并打印错误信息。</li><li>如果内存分配成功，代码将原始页的内容复制到新的页中。</li><li>然后，代码将新的页映射到页表中，并取消原始页的映射。这里使用了mappages函数来映射新的页，并使用kfree函数释放原始页的内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> || (((*pte &amp; PTE_W) == <span class="number">0</span>) &amp;&amp; ((*pte &amp; PTE_COW) == <span class="number">0</span>))) <span class="comment">//检查pte是否为0，或者PTE_V（页表项有效）和PTE_U（用户空间可访问）标志是否被设置，既不可写也不是COW</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW)) <span class="comment">//不可写且是COW</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">char</span> *mem;</span><br><span class="line">     <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)<span class="comment">//尝试为新的页分配内存</span></span><br><span class="line">     &#123;</span><br><span class="line">       not_enough_physical_memory_error:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Not enough physical memory when copy-on-write! \n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     memmove(mem, (<span class="type">char</span>*)PTE2PA(*pte), PGSIZE);<span class="comment">//代码将原始页的内容复制到新的页中</span></span><br><span class="line">     <span class="comment">//代码将新的页映射到页表中，并取消原始页的映射。这里使用了mappages函数来映射新的页，并使用kfree函数释放原始页的内存。</span></span><br><span class="line">     uint flags = PTE_FLAGS(*pte);</span><br><span class="line">     flags = (flags &amp; (~PTE_COW)) | PTE_W; <span class="comment">//置为可写，COW位置零</span></span><br><span class="line">     uvmunmap(pagetable, va0, <span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">     <span class="keyword">if</span>(mappages(pagetable, va0, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">       kfree(mem);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;This should never happen! The page SHOULD exist. mappages() won&#x27;t fail!!! \n&quot;</span>);</span><br><span class="line">       <span class="keyword">goto</span> not_enough_physical_memory_error;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>here&#39;s a post.</title>
      <link href="/2024/07/02/the-first/"/>
      <url>/2024/07/02/the-first/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Post </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reto </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
