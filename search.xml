<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【实验4】traps-lab</title>
      <link href="/2024/07/04/trapslab/"/>
      <url>/2024/07/04/trapslab/</url>
      
        <content type="html"><![CDATA[<h1 id="【实验4】traps-lab"><a href="#【实验4】traps-lab" class="headerlink" title="【实验4】traps-lab"></a>【实验4】traps-lab</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><h3 id="1-哪些寄存器包含函数的参数？例如，哪个寄存器在-main-对-printf-的调用中保存-13？"><a href="#1-哪些寄存器包含函数的参数？例如，哪个寄存器在-main-对-printf-的调用中保存-13？" class="headerlink" title="1.哪些寄存器包含函数的参数？例如，哪个寄存器在 main 对 printf 的调用中保存 13？"></a>1.哪些寄存器包含函数的参数？例如，哪个寄存器在 main 对 printf 的调用中保存 13？</h3><p>a0-a7寄存器包含函数的参数。a2寄存器在main对printf的调用中保存13</p><img src="https://gitee.com/retokani/pictures/raw/master/img/202407041802938.png" alt="img"  /><p><img src="https://gitee.com/retokani/pictures/raw/master/img/202407041802957.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reg    | name  | saver  | description</span><br><span class="line">-------+-------+--------+------------</span><br><span class="line">x0     | zero  |        | hardwired zero</span><br><span class="line">x1     | ra    | caller | return address</span><br><span class="line">x2     | sp    | callee | stack pointer</span><br><span class="line">x3     | gp    |        | global pointer</span><br><span class="line">x4     | tp    |        | thread pointer</span><br><span class="line">x5-7   | t0-2  | caller | temporary registers</span><br><span class="line">x8     | s0/fp | callee | saved register / frame pointer</span><br><span class="line">x9     | s1    | callee | saved register</span><br><span class="line">x10-11 | a0-1  | caller | function arguments / return values</span><br><span class="line">x12-17 | a2-7  | caller | function arguments</span><br><span class="line">x18-27 | s2-11 | callee | saved registers</span><br><span class="line">x28-31 | t3-6  | caller | temporary registers</span><br><span class="line">pc     |       |        | program counter</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">How are arguments passed?</span><br><span class="line">    a0, a1, ..., a7, rest on stack</span><br><span class="line">How are values returned?</span><br><span class="line">    a0, a1</span><br></pre></td></tr></table></figure><h3 id="2-Where-is-the-call-to-function-f-in-the-assembly-code-for-main-Where-is-the-call-to-g-Hint-the-compiler-may-inline-functions"><a href="#2-Where-is-the-call-to-function-f-in-the-assembly-code-for-main-Where-is-the-call-to-g-Hint-the-compiler-may-inline-functions" class="headerlink" title="2.Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)"></a>2.Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</h3><p>​main 的汇编代码没有调用 f 和 g 函数。编译器可以内联函数。</p><h3 id="3-At-what-address-is-the-function-printf-located"><a href="#3-At-what-address-is-the-function-printf-located" class="headerlink" title="3.At what address is the function printf located?"></a>3.At what address is the function printf located?</h3><p>0x614</p><p><img src="https://gitee.com/retokani/pictures/raw/master/img/202407041802325.png" alt="img"></p><h3 id="4-What-value-is-in-the-register-ra-just-after-the-jalr-to-printf-in-main"><a href="#4-What-value-is-in-the-register-ra-just-after-the-jalr-to-printf-in-main" class="headerlink" title="4.What value is in the register ra just after the jalr to printf in main?"></a>4.What value is in the register ra just after the jalr to printf in main?</h3><p>0x38</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span>:  <span class="number">00000097</span>       auipc   ra,<span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="number">34</span>:  <span class="number">612080e7</span>       jalr <span class="number">1554</span>(ra) # <span class="number">642</span> &lt;printf&gt;</span><br></pre></td></tr></table></figure><pre><code>      auipc就是把一个数左移12位，后再加上pc值</code></pre><p>​ <code>JALR rd，offset(rs1)</code></p><p>​jalr该指令将PC设置为rs1寄存器中的值加上符号位扩展的偏移量，把计算出地址的最低有效位设为0，并将原PC + 4的值写入rd寄存器。如果不需要目的寄存器，可以将rd设置为x0。如果只有offset(ra)，把pc+4存入ra</p><h3 id="5-输出是什幺？输出取决于-RISC-V-是小端这一事实。如果-RISC-V-是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616"><a href="#5-输出是什幺？输出取决于-RISC-V-是小端这一事实。如果-RISC-V-是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616" class="headerlink" title="5.输出是什幺？输出取决于 RISC-V 是小端这一事实。如果 RISC-V 是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616"></a>5.输出是什幺？输出取决于 RISC-V 是小端这一事实。如果 RISC-V 是大端的，为了产生相同的输出，你会设置什幺？是否需要更改为其他值？i57616</h3><p>​<a href="https://cpp.sh/?source=%23include+%3Cstdio.h%3E%0D%0Aint+main()%7B++%0D%0A++++unsigned+int+i+=+0x00646c72;%0D%0Aprintf(%22H%25x+Wo%25s%22,+57616,+&i);%0D%0A++++return+0;%7D">代码</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/retokani/pictures/raw/master/img/202407041802197.png" alt="img"></p><p>​57616 十六进制为 e110。 大端和小端不改变真正的值的大小，所以 57616 始终打印为e110 。</p><p>​在小端处理器中，数据高字节存储在内存的高位，从内存低位，也就是低字节开始读取，0x00646c72为rld。在大端处理器中，dlr。大端时，i 的值应该为0x726c64。</p><h3 id="6-In-the-following-code-what-is-going-to-be-printed-after-note-the-answer-is-not-a-specific-value-Why-does-this-happen-‘y-’"><a href="#6-In-the-following-code-what-is-going-to-be-printed-after-note-the-answer-is-not-a-specific-value-Why-does-this-happen-‘y-’" class="headerlink" title="6.In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? ‘y&#x3D;’"></a>6.In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? ‘y&#x3D;’</h3><p>​ <code>printf(&quot;x=%d y=%d&quot;, 3);</code>[代码](<a href="https://cpp.sh/?source=//+Example+program">https://cpp.sh/?source=%2F%2F+Example+program</a> %23include+ int+main() { ++printf(“x%3D%d+y%3D%d”%2C+3)%3B return+0%3B })</p><p>​ <em>x&#x3D;3 y&#x3D;0</em></p><p>​ prinf 少传了一个参数，会从参数传递寄存器中读取一个不确定的值，‘y&#x3D;’ 后面的值不能确定。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>对于调试来说，进行回溯通常很有用：在发生错误的位置上方堆栈上的函数调用列表。为了帮助进行回溯，编译器会生成<strong>机器代码</strong>，该代码在堆栈上维护与当前调用链中每个函数相对应的堆栈帧。每个<strong>堆栈帧</strong>都包含<strong>返回地址</strong>和指向调用者堆栈帧的“<strong>帧指针</strong>”。寄存器 <strong>s0</strong>包含指向当前堆栈帧的指针（它实际上指向堆栈上保存的返回地址的地址加 8）。您的回溯应该使用帧指针遍历堆栈并在每个堆栈帧中打印保存的返回地址。</p><p>在riscv.h中加入r_fp()函数来阅读s0</p><p>请注意，返回地址位于堆栈帧的帧指针的固定偏移量 （-8） 处，保存的帧指针位于距帧指针的固定偏移量 （-16） 处</p><p>fp帧指针，sp栈指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack:</span><br><span class="line">      |   | local variables |</span><br><span class="line">      |   |       ...       | &lt;-+</span><br><span class="line">      |   +-----------------+   |</span><br><span class="line">      |   | return address  |   |</span><br><span class="line">      +------ previous fp   |   |</span><br><span class="line">          | saved registers |   |</span><br><span class="line">          | local variables |   |</span><br><span class="line">  $fp --&gt; |       ...       |   |</span><br><span class="line">          +-----------------+   |</span><br><span class="line">          | return address  |   |</span><br><span class="line">          |   previous fp ------+</span><br><span class="line">          | saved registers |</span><br><span class="line">  $sp --&gt; | local variables |</span><br><span class="line">          +-----------------+</span><br></pre></td></tr></table></figure><p>需要一种方法来识别它已经看到了最后一个堆栈帧，并且应该停止。一个有用的事实是，为每个内核堆栈分配的内存由单个页面对齐的页面组成，因此给定堆栈的所有堆栈帧都在同一页面上。可以使用 PGROUNDDOWN（fp）来标识帧指针引用的页面。</p><p>在kernel&#x2F;printf.c中加入一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp_address = r_fp();</span><br><span class="line">  <span class="keyword">while</span>(fp_address != PGROUNDDOWN(fp_address)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp_address<span class="number">-8</span>));</span><br><span class="line">    fp_address = *(uint64*)(fp_address - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>在本练习中，您将向 xv6 添加一项功能，该功能会在进程使用 CPU 时间时定期发出警报。<br>实现用户级中断&#x2F;故障处理进程的原始形式;例如，您可以使用类似的东西来处理应用进程中的页面错误。如果通过 alarmtest 和“usertests -q”，则您的解决方案是正确的。</p><p>您应该添加一个新的 sigalarm（interval， handler） 系统调用。<br>如果应用进程调用 sigalarm（n， fn），则在进程消耗的 CPU 时间每 n 个“滴答”后，内核应调用应用进程函数 fn。<br>当 fn 返回时，应用进程应从中断的地方继续。刻度是 xv6 中相当任意的时间单位，由硬件计时器生成中断的频率决定。如果应用进程调用 sigalarm（0， 0），内核应停止生成周期性警告调用。</p><p>当使用 trap 方式陷入内核的时候，会执行 <code>kernel/trampoline.S</code> 中的 <code>uservec</code> ：<br>save user a0 in sscratch so a0 can be used to get at TRAPFRAME.<br>save the user registers in TRAPFRAME<br>jump to usertrap() in trap.c , which does not return：<br>①检测scause，为8的话去syscall，<code>p-&gt;trapframe-&gt;epc += 4;</code>(sepc points to the ecall instruction, but we want to return to the next instruction.)<br>②give up the CPU if this is a timer interrupt.<br> <code>if(which_dev == 2)yield();</code><br> <code>usertrapret();</code> (also in trap.c):<br>send syscalls, interrupts, and exceptions to uservec in trampoline.S<br>set up trapframe values that uservec will need when the process next traps into the kernel.<br>set up the registers that trampoline.S’s sret will use to get to user space.<br>jump to userret in trampoline.S  </p><p>在sysproc.c中加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">proc</span> =</span> myproc();</span><br><span class="line">  *proc-&gt;trapframe = proc-&gt;saved_trapframe;</span><br><span class="line">  proc-&gt;have_return = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> proc-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler_va;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;ticks);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;handler_va);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">proc</span> =</span> myproc();</span><br><span class="line">  proc-&gt;alarm_interval = ticks;</span><br><span class="line">  proc-&gt;handler_va = handler_va;</span><br><span class="line">  proc-&gt;have_return = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在trap.c中修改usertrap():(上面提到过的代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;alarm_interval &amp;&amp; proc-&gt;have_return) &#123;</span><br><span class="line">    <span class="keyword">if</span> (++proc-&gt;passed_ticks == <span class="number">2</span>) &#123;</span><br><span class="line">      proc-&gt;saved_trapframe = *p-&gt;trapframe;</span><br><span class="line">      proc-&gt;trapframe-&gt;epc = proc-&gt;handler_va;</span><br><span class="line">      proc-&gt;passed_ticks = <span class="number">0</span>;</span><br><span class="line">      proc-&gt;have_return = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【实验5】Copy-on-Write</title>
      <link href="/2024/07/04/%E5%AE%9E%E9%AA%8C5/"/>
      <url>/2024/07/04/%E5%AE%9E%E9%AA%8C5/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab5-Copy-on-Write-Fork-for-xv6"><a href="#Lab5-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab5: Copy-on-Write Fork for xv6"></a>Lab5: Copy-on-Write Fork for xv6</h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p><strong>问题：</strong>xv6 中的 fork() 系统调用会将父进程的所有用户空间内存复制到子进程中。如果父进程很大，拷贝可能需要很长时间。更糟糕的是，这些工作通常会被浪费掉：fork() 之后，子进程通常会执行 exec()，丢弃复制的内存，通常不会使用其中的大部分。另一方面，如果父进程和子进程都使用了复制的页面，并且其中一个或两个都写入了该页面，那么复制就是真正需要的。</p><p><strong>需要实现的：</strong>实现写入时拷贝（COW）fork() 的目的是推迟分配和拷贝物理内存页，直到实际需要时才拷贝（如果需要的话）。COW fork() creates just a pagetable for the child, with PTEs for user memory pointing to the parent’s physical pages. COW fork() 只为子进程创建一个分页表，其中的用户内存 PTE 指向父进程的物理页面。COW fork() 会将父进程和子进程中的所有用户 PTE 标记为只读。当任何一个进程试图写入这些 COW 页面时，CPU 都会强制产生一个页面故障。内核页面故障处理程序会检测到这种情况，为故障进程分配一页物理内存，将原始页面复制到新页面，并修改故障进程中的相关 PTE 以引用新页面，这次的 PTE 标记为可写。当页面故障处理程序返回时，用户进程将能写入其页面副本。</p><p>​COW fork() 在释放实现用户内存的物理页时比较麻烦。一个给定的物理页可能会被多个进程的页表引用，只有当最后一个引用消失时，才能释放该页。在 xv6 这样的简单内核中，这种管理相当简单明了，但在生产内核中却很难做到这一点。</p><p>这里有一个合理的攻击计划：</p><ol><li><p>修改 uvmcopy() 以将父代的物理页面映射到子代，而不是分配新的页面。对于设置了 PTE_W 的页面，清除子代和父代 PTE 中的 PTE_W。</p></li><li><p>修改 usertrap() 以识别页面故障。当原本可写的 COW 页面出现写页面故障时，使用 kalloc() 分配新页面，将旧页面复制到新页面，并将新页面安装到设置了 PTE_W 的 PTE 中。原本只读的页面（未映射 PTE_W，如文本段中的页面）应保持只读并在父进程和子进程之间共享；试图写入此类页面的进程应被杀死。</p></li><li><p>确保每个物理页面在最后一次 PTE 引用消失时被释放，而不是在此之前。一个很好的方法是为每个物理页保留一个 “引用计数”，即引用该页的用户页表的数量。在 kalloc() 分配页面时，将页面的引用计数设为 1。只有当页面的引用计数为零时，kfree() 才会将该页面放回空闲列表。将这些计数保存在一个固定大小的整数数组中也是可以的。你必须为如何索引数组和如何选择数组大小制定一个方案。例如，你可以用页面的物理地址除以 4096 作为数组的索引，并给数组一个元素数，该元素数等于 kalloc.c 中 kinit() 放在空闲列表上的任何页面的最高物理地址。</p></li><li><p>修改 copyout() 以在遇到 COW 页面时使用与页面故障相同的方案。</p></li></ol><p>一些提示：</p><ol><li>记录每个 PTE 是否是 COW 映射的方法可能很有用。为此，可以使用 RISC-V PTE 中的 RSW（为软件保留）位。</li><li>usertests -q 可以探索 cowtest 无法测试的情况，因此不要忘记检查两者是否都通过了所有测试。</li><li>在 kernel&#x2F;riscv.h 的末尾有一些有用的宏和页表标志定义。</li><li>如果发生 COW 页面错误且没有可用内存，则应杀死进程。</li></ol><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>在物理内存中，XV6中的Shell通常会有4个page，当调用fork时，基本上就是创建了4个新的page，并将父进程page的内容拷贝到4个新的子进程的page中。</p><p><img src="https://gitee.com/retokani/pictures/raw/master/img/202407041837158.png" alt="imageNu2"></p><h3 id="在riscv-h中（判断位）"><a href="#在riscv-h中（判断位）" class="headerlink" title="在riscv.h中（判断位）"></a>在riscv.h中（判断位）</h3><p>RSW可以随意使用，加入标志位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><h3 id="在kalloc-c中：（处理计数）"><a href="#在kalloc-c中：（处理计数）" class="headerlink" title="在kalloc.c中：（处理计数）"></a>在kalloc.c中：（处理计数）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> page_refcnt[PHYSTOP/PGSIZE]; <span class="comment">// COW reference count. </span></span><br></pre></td></tr></table></figure><p>这里的<code>volatile</code>关键字用于确保对<code>page_refcnt</code>数组的每次访问都是独立的，不会被缓存。这样可以确保在并发环境下，对<code>page_refcnt</code>数组的访问是正确的。<code>volatile</code>关键字的作用是：当一个变量被声明为<code>volatile</code>时，编译器会确保对它的每次访问都会直接从内存中读取，而不是从缓存中读取。这可以确保对<code>page_refcnt</code>数组的每次访问都是独立的，不会被缓存。0</p><h4 id="在kfree-函数中加入（用于计数减一）："><a href="#在kfree-函数中加入（用于计数减一）：" class="headerlink" title="在kfree()函数中加入（用于计数减一）："></a>在kfree()函数中加入（用于计数减一）：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(page_refcnt[(uint64)pa/PGSIZE]&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    page_refcnt[(uint64)pa/PGSIZE] -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(page_refcnt[(uint64)pa/PGSIZE]&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  ···</span><br></pre></td></tr></table></figure><h4 id="在kalloc-函数中："><a href="#在kalloc-函数中：" class="headerlink" title="在kalloc()函数中："></a>在kalloc()函数中：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_refcnt[(uint64)r/PGSIZE] = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><h3 id="在trap-c中：（处理故障）"><a href="#在trap-c中：（处理故障）" class="headerlink" title="在trap.c中：（处理故障）"></a>在trap.c中：（处理故障）</h3><p>加入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> page_refcnt[PHYSTOP/PGSIZE];</span><br></pre></td></tr></table></figure><h4 id="在usertrap-中："><a href="#在usertrap-中：" class="headerlink" title="在usertrap()中："></a>在usertrap()中：</h4><p>判断scause是8的话去syscall，然后判断是否有中断发生：<code>else if((which_dev = devintr()) != 0)</code></p><p><img src="https://gitee.com/retokani/pictures/raw/master/img/202407041817747.png" alt="202407041801051"></p><p>存储&#x2F;原子操作页故障（Store&#x2F;AMO page fault）：当用户进程尝试将数据写入一个只读页面时，会发生这种异常。在这种情况下，代码会检查页表项（pte）是否包含Copy-on-Write（COW）标志。如果包含，那么它会为该页面分配一个新的物理页面，将旧页面复制到新页面，并将页表项更改为可写状态。如果不包含COW标志，那么它会打印一条错误消息并终止进程。</p><ol><li>获取当前异常的虚拟地址（write_va）。</li><li>检查虚拟地址是否在最大虚拟地址（MAXVA）范围内。如果不在这个范围内，那么就跳转到unexpected_scause标签，表示这是一个意外的异常。</li><li>获取当前进程的页表（pagetable）。</li><li>使用walk函数在页表中查找虚拟地址对应的页表项（pte）。</li><li>检查页表项是否包含COW标志。如果包含COW标志，那么说明这个页面是一个COW页面。</li><li>为新的页面分配内存（mem）。</li><li>将原始页面的内容复制到新的内存中（memmove）。</li><li>将新的页面映射到页表中，并取消原始页面的映射（uvmunmap和kfree）。</li><li>如果映射新页面失败，那么释放分配的内存，并跳转到not_enough_physical_memory_error标签，表示没有足够的物理内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(r_scause()==<span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      uint64 write_va = r_stval();<span class="comment">//获取当前异常的虚拟地址（write_va）</span></span><br><span class="line">      <span class="keyword">if</span>(write_va&gt;=MAXVA) <span class="keyword">goto</span> unexpected_scause; <span class="comment">//检查虚拟地址是否在最大虚拟地址（MAXVA）范围内。如果不在这个范围内，那么就跳转到unexpected_scause标签，表示这是一个意外的异常</span></span><br><span class="line">      <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;<span class="comment">//获取当前进程的页表（pagetable）</span></span><br><span class="line">      <span class="type">pte_t</span> *pte = walk(pagetable, write_va, <span class="number">0</span>);<span class="comment">//使用walk函数在页表中查找虚拟地址对应的页表项（pte）</span></span><br><span class="line">      <span class="keyword">if</span>(*pte &amp; PTE_COW) <span class="comment">//这个页面是一个COW页面</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//为新的页面分配内存（mem）</span></span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">          not_enough_physical_memory_error:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Not enough physical memory when copy-on-write! pid=%d\n&quot;</span>, p-&gt;pid);</span><br><span class="line">          setkilled(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将原始页面的内容复制到新的内存中（memmove）</span></span><br><span class="line">        memmove(mem, (<span class="type">char</span>*)PTE2PA(*pte), PGSIZE);</span><br><span class="line"><span class="comment">//将新的页面映射到页表中，并取消原始页面的映射（uvmunmap和kfree）</span></span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        flags = (flags &amp; (~PTE_COW)) | PTE_W; <span class="comment">//标为可写，且不是COW页面</span></span><br><span class="line">        uvmunmap(pagetable, PGROUNDDOWN(write_va), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mappages(pagetable, PGROUNDDOWN(write_va), PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;<span class="comment">//检查是否能够成功将内存映射到指定的虚拟地址。映射成功后，将内存块的指针mem分配给指定的虚拟地址。如果映射失败，则释放内存块。</span></span><br><span class="line">          kfree(mem);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;This should never happen! The page SHOULD exist. mappages() won&#x27;t fail!!! \n&quot;</span>);</span><br><span class="line">          <span class="keyword">goto</span> not_enough_physical_memory_error;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//不是COW页面</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">goto</span> unexpected_scause;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      unexpected_scause:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      setkilled(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>sepc寄存器，一言以蔽之就是记录陷阱陷入到S-Mode时发生陷阱的指令的虚拟地址，它在执行陷阱时会记录下被中断的指令的虚拟地址</p><p>缺页故障发生时，stval就会记录到底是对哪个虚拟地址的访问导致了本次缺页故障，内核就可以根据此信息去加载页面进入内存。指令执行非法(illegal instruction, 异常号为2)：当执行的指令非法时，stval会将这条指令的一部分位记录下来。</p><h3 id="在vm-c中：（处理映射）"><a href="#在vm-c中：（处理映射）" class="headerlink" title="在vm.c中：（处理映射）"></a>在vm.c中：（处理映射）</h3><p>一样先加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> page_refcnt[PHYSTOP/PGSIZE];</span><br></pre></td></tr></table></figure><h4 id="修改uvmcopy-函数："><a href="#修改uvmcopy-函数：" class="headerlink" title="修改uvmcopy()函数："></a>修改uvmcopy()函数：</h4><p>原先：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">  <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">    </span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);<span class="comment">//复制页面</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后：</p><p>既然我们使用了Copy-on-Write（COW）机制，就没有必要复制页面。我们将原始页映射到子进程的页表中，然后在父进程和子进程的页表项中，将PTE_W标志（写权限标志）设置为0，将自定义的PTE_COW标志（Copy-on-Write标志）设置为1。</p><p>这样，当子进程试图写入原始页时，系统会自动分配一个新的页，并将原始页的内容复制到新页中。同时，由于父进程和子进程的页表项中的PTE_W标志都为0，所以子进程无法修改原始页。这样，我们就实现了Copy-on-Write机制，从而减少了内存操作的次数，提高了系统性能。</p><ol><li>如果父页表项具有可写标志（PTE_W），则将其设置为新标志（PTE_COW）。</li><li>将原始页映射到子页表中，并设置新的标志。如果映射失败，则跳转到错误处理。</li><li>增加原始页的引用计数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (*pte &amp; PTE_W) *pte = (*pte ^ PTE_W) | PTE_COW; <span class="comment">//如果父页表项具有可写标志（PTE_W），设置为0，cow设置为1</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(new, i, PGSIZE, pa, PTE_FLAGS(*pte)) != <span class="number">0</span>) <span class="keyword">goto</span> err;<span class="comment">//将原始页映射到子页表中，并设置新的标志。如果映射失败，则跳转到错误处理。</span></span><br><span class="line">    page_refcnt[(uint64)pa / PGSIZE] += <span class="number">1</span>; <span class="comment">//增加原始页的引用计数。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="修改copyout函数："><a href="#修改copyout函数：" class="headerlink" title="修改copyout函数："></a>修改copyout函数：</h4><p>原先：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> || (*pte &amp; PTE_W) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>修改后：</p><p>它处理的是当遇到一个写保护（PTE_W）或COW（Copy-on-Write）标志被设置的页表项（pte）时的情况。</p><ol><li>首先，代码检查pte是否为0，或者PTE_V（页表项有效）和PTE_U（用户空间可访问）标志是否被设置。如果这些条件不满足，函数返回-1。</li><li>接下来，代码检查PTE_W（写保护）标志是否被设置，以及PTE_COW（Copy-on-Write）标志是否被设置。如果PTE_W标志没有被设置，且PTE_COW标志被设置，那么表示遇到了一个COW页。</li><li>对于COW页，代码首先尝试为新的页分配内存。如果内存分配失败，函数跳转到not_enough_physical_memory_error标签，并打印错误信息。</li><li>如果内存分配成功，代码将原始页的内容复制到新的页中。</li><li>然后，代码将新的页映射到页表中，并取消原始页的映射。这里使用了mappages函数来映射新的页，并使用kfree函数释放原始页的内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> || (((*pte &amp; PTE_W) == <span class="number">0</span>) &amp;&amp; ((*pte &amp; PTE_COW) == <span class="number">0</span>))) <span class="comment">//检查pte是否为0，或者PTE_V（页表项有效）和PTE_U（用户空间可访问）标志是否被设置，既不可写也不是COW</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW)) <span class="comment">//不可写且是COW</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">char</span> *mem;</span><br><span class="line">     <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)<span class="comment">//尝试为新的页分配内存</span></span><br><span class="line">     &#123;</span><br><span class="line">       not_enough_physical_memory_error:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Not enough physical memory when copy-on-write! \n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     memmove(mem, (<span class="type">char</span>*)PTE2PA(*pte), PGSIZE);<span class="comment">//代码将原始页的内容复制到新的页中</span></span><br><span class="line">     <span class="comment">//代码将新的页映射到页表中，并取消原始页的映射。这里使用了mappages函数来映射新的页，并使用kfree函数释放原始页的内存。</span></span><br><span class="line">     uint flags = PTE_FLAGS(*pte);</span><br><span class="line">     flags = (flags &amp; (~PTE_COW)) | PTE_W; <span class="comment">//置为可写，COW位置零</span></span><br><span class="line">     uvmunmap(pagetable, va0, <span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">     <span class="keyword">if</span>(mappages(pagetable, va0, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">       kfree(mem);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;This should never happen! The page SHOULD exist. mappages() won&#x27;t fail!!! \n&quot;</span>);</span><br><span class="line">       <span class="keyword">goto</span> not_enough_physical_memory_error;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>here&#39;s a post.</title>
      <link href="/2024/07/02/the-first/"/>
      <url>/2024/07/02/the-first/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Post </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>口是心非的墓志铭（未授权翻译）</title>
      <link href="/2024/07/02/%E5%8F%A3%E6%98%AF%E5%BF%83%E9%9D%9E%E7%9A%84%E5%A2%93%E5%BF%97%E9%93%AD/"/>
      <url>/2024/07/02/%E5%8F%A3%E6%98%AF%E5%BF%83%E9%9D%9E%E7%9A%84%E5%A2%93%E5%BF%97%E9%93%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="口是心非的墓志铭"><a href="#口是心非的墓志铭" class="headerlink" title="口是心非的墓志铭"></a>口是心非的墓志铭</h1><p><a href="https://archiveofourown.org/users/Azazellokun21/pseuds/Azazellokun21">Azazellokun21</a>、[WTF 山姆·洛克威尔和角色 2021 （WTF_Sam_Rockwell_and_roles_2021）](<a href="https://archiveofourown.org/users/WTF_Sam_Rockwell_and_roles_2021/pseuds/WTF">https://archiveofourown.org/users/WTF_Sam_Rockwell_and_roles_2021/pseuds/WTF</a> Sam Rockwell and roles 2021)</p><p>总结：</p><p>马蒂喝醉到失去知觉，比利不知不觉地陷入了爱河。</p><p>笔记：</p><p>Precanon， 不健康的关系， 暴力， 异性恋 （achtung！），， 脏话， （包括醉酒）， 抚摸， 公正， 淫秽的语言， 记忆力减退， 酗酒， 历史， OOS.</p><p>性别评级。</p><p>Marty&#x2F;Billy &amp; Billy&#x2F;Marty是主船，其他一切都是深度次要的。</p><p>书中提到了其他电影和原始剧本。它们不会影响文本的感知，它们只是存在。因此，如果某件事在你看来在某个地方，它就不是你觉得的。</p><h2 id="第-1-章：序幕"><a href="#第-1-章：序幕" class="headerlink" title="第 1 章：序幕"></a><a href="https://archiveofourown.org/works/29239866/chapters/71797359">第 1 章</a>：序幕</h2><p>Chapter Text</p><p>绝妙的想法就像奸诈的妓女：她们想什么时候来就来，又以同样的方式离开你。你可以一辈子等待他们，但他们会出现在那个悲惨的时刻，当你的妻子将死于癌症，或者你最好的朋友将被已故的黑手党分子射中额头时。</p><p>马丁·法兰南 - 年轻、成功、有才华 - 作为一名作家，他已经完全筋疲力尽了，他才三十多岁。他的想法残余可悲地溅在瓶子底部的某个地方，疲惫不堪，味道令人作呕。只剩下一股昔日伟大的恶臭。但回到领奖台上还为时不晚。</p><p>但是，十年前无可救药地失去了演艺事业的成功，从那时起就一直在事业上直奔屁股的威廉·比克尔，他只有一个惊人的想法。然而，她的出生并非偶然。</p><p>出于无聊或甩掉积累的压力，或者为了寻找神奇的内啡肽（必要的和不必要的），他有时会和比佛利山庄的可爱但无聊的天使啜饮。她的黑手党朋友和一只扁脸狗的照片散落在整个别墅里。安吉拉不停地谈论这个混蛋，可能只有在别人把她插好时才闭嘴，（显然，播放模式是开着的）。比利受够了她的胡说八道。他也厌倦了听马蒂抱怨剧本没写好，没有创意，一团糟，我怎么会喝醉，怎么会死，等等。只有当他不关心安吉拉时，他才会关心马蒂的问题。</p><p>然后有一天，他躺在床上，厌恶地回忆起他的性伴侣的男朋友的照片（陈旧的、无休止的、真他妈的不堪入目的香艳照片），他突然想：如果能摆脱所有这些黑手党混蛋，那该有多酷，甚至是贵族。包括黑帮。</p><p>试想一下：比如说，如果 Capone 在那里，或者 Rothstein 被一个戴着面具的陌生人枪杀。没有理由。他不需要金钱或名声，他根本不需要任何东西，也没有人知道他为什么要杀死黑手党。但它看起来令人印象深刻。就像一个超级英雄。事实上，确实如此：既然有组织犯罪肯定已经惹恼了所有人，他们就会感谢那个戴面具的家伙。</p><p>比利决定，这将是一个很好的角色，他微笑着想象马蒂听到这个想法会有多高兴。然后他又皱起了眉头：马蒂是一个脆弱的灵魂，如果只是把一个想法放在银盘上交给他，然后说：”写吧，亲爱的！这都是为了你！” 不，那行不通，因为马蒂是只骄傲的鸟。马蒂需要的是自己的东西 而不是别人的礼物 从生活中汲取的东西才行</p><p>然后比利脑子里灵光一闪：</p><p>“为什么不呢？！”</p><p>他知道如何射击。即使是用两只手（感谢你，亲爱的电影院，感谢你的宝贵经验）。顺便说一句，枪也有了。剩下的就是超级英雄的装备了。这个形象和名字会让人记忆犹新，立刻让人联想到一些众所周知的东西。</p><p>比利的目光在房间里徘徊，落在一副纸牌和一顶针织红帽上，在悲伤的时刻被鞭打。</p><p>卡牌。<br> 红色。<br> 钻石。<br> 杰克。</p><p>他的个人联想能力陷入了地狱，但结果证明这张照片很酷。</p><p>Billy 从床上跳下来，开始计划……</p><p>有时候，想法太聪明了。它们像寄生虫一样侵蚀着作者的意识，征服并扼杀着。直到死前，作者–身心俱疲–都确信自己创造了一部杰作。那些堆积如山的尸体和支离破碎的生命都是值得的。他的名字将被宇宙铭记。</p><p>就 Billy 而言，他准备将他的杰作扔到 Marty 的脚下。然后发现自己就在那里。而他，该死的，会做到的！比利自信地向 Costello 帮派的两个狡猾的家伙前进，并瞄准他们的后脑勺。他知道，杀死他们后，他不会在晚上停止睡眠，不会受到良心的痛苦的折磨，也不会因自我厌恶而经历无休止的恶心发作。他不会感受到一个正常人会有的一切感受，不会感受到马蒂杀人后会感受到的一切。不，他根本不在乎这些猪，不在乎它们要受多久的罪，会不会有人为它们哭泣。他们只是很不幸地挡住了创造杰作的创作者的去路。但他们成功地发挥了自己的作用。</p><p>比利在开枪后所感受到的是一种愉快的兴奋，因为他已经向目标迈出了第一步。</p><p>但关于这一步，关于 Billy 的个人贡献，Marty 永远不应该知道。以及许多其他可能让他心碎的事情。</p><p>例如，如果马蒂知道比利对他的看法或在日记里写的东西的哪怕十分之一，他早就把他送走了，还申请了对他的限制令，以防万一（也不是没有原因的）。</p><p>或者 Billy 何时、何地和谁乱搞。任何有关的信息都会让马蒂从嫉妒的冷嘲热讽到完全否认。他可能没有注意到他的反应，但比利注意到了。所以，不，Marty，我根本没有女朋友。我的生命中只有一个女孩——你，为了你自己的利益，你最好不要知道她，以及许多其他事情。你根本不了解。</p><p>你不了解你自己，马蒂。<br> 你不了解自己。</p><p>一个就够了，为什么还要七个神经病？但你真的需要这个场景和这个结局来了解自己并敞开心扉。<br> 是时候结束这场无休止的暴力、破碎和重新结合的心灵的噩梦了。开所有隐藏在微笑背后的谎言。是时候死去了，从而为伟大的事物服务。留下一些东西。因此，死亡的那一刻会比一个普通的美国失败者——一个毫无价值的演员狗贼——的一生好一千倍。然后他们将拍摄一部大片，比利将至少由马特·达蒙扮演。而《七个精神病患者》将有如此盛大的结局，以至于观众在演职员表期间会淹没在咆哮中！</p><p>哦，比利很期待这个结局。他把毛茸茸、平脸、可爱得令人难以置信的西施犬抱在怀里，已经画出了残忍的科斯特洛如何在震惊的马蒂面前判处他死刑。</p><p>然后一切都会结束。</p><p>如果不是墓地土地的价格像要飞向太空一样昂贵，如果比利的命运没有落在一个廉价、无用的骨灰盒中，他仍然会得到自己的墓碑。雪白的大理石。他们会在上面写一些自命不凡但完全反映他的现实的东西：“他绝望了，过着短暂而光明的一生。内心焦灼，每天都像火柴一样燃起又燃尽。他为一个人而活，为他而死，就像一条忠实的狗。他受尽折磨，而且死得很漂亮，摆脱了痛苦。”不，这太长了。</p><p>他的墓志铭将是：“比利·比克尔。最好的朋友和口是心非的败类。”</p><h2 id="第-2-章：比利。1-距离最终枪战还有一年零八个月"><a href="#第-2-章：比利。1-距离最终枪战还有一年零八个月" class="headerlink" title="第 2 章：比利。1. 距离最终枪战还有一年零八个月"></a><a href="https://archiveofourown.org/works/29239866/chapters/71797545">第 2 章</a>：比利。1. 距离最终枪战还有一年零八个月</h2><p>Chapter Text</p><p>现在，比利最想看到的就是kaya。他想看到那个婊子走进屋子，看到她瞳孔放大，在迷惑中凝固。看到她脸上即将出现的歇斯底里的阴影，看到她泪光闪烁。如果马蒂此时正握着他的鸡巴，比利一定会达到高潮。傲慢地直视着这个婊子的眼睛。然后，他用双手搂住马蒂的脖子，把鼻子贴在他湿漉漉的太阳穴上，咧嘴一笑，急切而下流地说道：“看看你的男人现在在哪里，宝贝。我想你不应该把他一个人留下，是吧？别他妈的甩你的脸。</p><p>这种幻想刺激着他，他再次用力将嘴唇贴在马蒂的嘴唇上，拉紧了那件愚蠢的运动衫。马蒂坐在他身上，背对着出口（这样他就不会注意到那个婊子回来了）。马蒂的手在他的衬衫下摸索着，轻轻地、毫不犹豫地向下移动，比利坐在沙发上，正爽得死去活来。</p><p>虚脱的醉醺醺的马蒂狠狠地躁动着自己的老二，试图让自己的老二恢复活力，并像刺猬一样恶毒地哼着。一只和女友吵架的毛茸茸的可爱刺猬。</p><p>“她可能会回来的，”Billy 毫不掩饰地幸灾乐祸地警告道。</p><p>马蒂咆哮着反咬了一口。</p><p>会有瘀伤。这样就更好了。他想让马蒂死去，让这一刻永远持续下去。</p><p>去他妈的kaya。去他妈的友谊和所有这些关于朋友据称不被允许做爱的狗屁。现在，他们要在那个生气的婊子的眼皮底下做爱，那个婊子已经干到了晚上，但随时都有可能回来，抓住他们，让他们开心地干她。当然，如果马蒂能勃起，他们就会做爱，至于明天——那是明天。</p><p>现在一切都完了。</p><p><em>明天</em><em>……</em></p><p>马蒂的手指歪歪扭扭、醉醺醺地走向目的地。在摆弄皮带几秒钟后（意料之中没用），他们隔着牛仔裤紧紧抓住了比利。他浑身一震。他把头往后一仰，怔怔地望着天花板，浑身颤抖着，像一条吃不饱的狗一样被插进手掌里。马蒂–依然没有勃起，依然凶狠–喉咙里发出噗哧噗哧的声音，如此猛烈和炙热，比利已经做好了万一被吸血鬼折磨的准备。一条掠夺性的舌头沿着他的动脉游走。</p><p><em>就算你把我咬死了，也不要把手拿开，他妈的拜托了！</em></p><p><em>…**明天就很糟糕了。</em></p><p>他的心跳停止了。比利感到他的心情直接从炎热的地狱被扔进了寒冷的极地。他为此恨自己。毕竟，一切都是如此美好！曾经是。他妈的甚至不会是明天，而是几分钟后，这一切就会变得一团糟——只要他把他最好的朋友放在他手里。马蒂像一千个魔鬼一样醉醺醺和愤怒，显然对他的行为一无所知。马蒂的高潮今天不会被看到，如果比利现在趁火打劫，那他就是个混蛋。并不是说他是一个高贵的王子或者道德的捍卫者（拜托），但这是他最好的朋友，该死的！是马蒂！ </p><p>“这是什么狗屎，” 他咆哮着，眼睛从天花板上瞟来瞟去。马蒂似乎什么也没听见，仍然缩在下面，用醉醺醺的幅度抚摸着比利渐渐变软的勃起。</p><p>比利几乎要呜咽了。真让人失望 我也应该喝上一杯，那样我就会毫不犹豫地放弃马蒂了。清醒阻碍了我的生活，是时候戒酒了，不过比利在跟谁开玩笑呢？</p><p>他猛地抓住马蒂的手腕–耳边传来一声愤愤不平的声音–然后把手抽了出来。一个凌乱的脑袋同样突然出现在他的面前。皱眉说，“你他妈在干什么，比克尔？”</p><p>马蒂显然认为这是一场游戏，他像胡迪尼一样灵巧地在几毫秒内松开了手，比利发现自己被锁在了沙发上，两边都是。马蒂贪婪地吸吮着他的嘴唇。</p><p>“操，”在他的脑袋里飞过，然后他们又疯狂地舔了起来。比利意识到他的情绪再次违背他的意愿而上升，这让他感到难过。</p><p>他还是试图把马蒂从他身上推开，但他控制不住自己。马蒂对这一转变很不满意，败下阵来的比利又倒在了沙发上。他倒在沙发上，立刻剧烈地反抗起来，但还是轻轻地，连半点力气都没有。而那个略显赤裸的性爱狂（又名最好的朋友、失败的情人、兼职的狗屁爱尔兰人）飞快地跑到了沙发的另一端。他做了个愤怒的表情，迅速跳起来挥拳。</p><p>Billy 不合时宜地眨了眨眼……</p><p>指关节在他脸上划出一道道灼热的痕迹，皮肤瞬间火辣辣的</p><p>…他僵住了。目瞪口呆地看着马蒂。</p><p>他喘着粗气，痛苦地弯下手腕（这一巴掌打得不轻），瞪大眼睛，好像很惊讶，好像不知道发生了什么，也不知道为什么胳膊会疼。</p><p>两个人都盯着对方。静静地。他们意识到，一个美好的夜晚，一个值得纪念的夜晚，如果马蒂还记得什么的话，已经被胜利地搞砸了。马蒂渐渐平静下来，完全停止了呼吸。他看起来就像一只被打败的小狗。</p><p>Billy 移开了视线。</p><p>“为什么？” “安静。”</p><p>没有恶意。空空如也。</p><p>Marty蜷缩在沙发背上</p><p>“我不……Billy，对不起。我不明白……</p><p>“没事的，一切都很好。这是我自己的错。我毁了一切。”他感到嘴角湿润，它似乎破了。Billy用手指轻轻抚摸 用舌头舔了舔。“我要走了 你需要好好睡一觉。”</p><p>“搞什么 比利 别把我一个人留在这 我去拿急救箱，等等…”</p><p>马蒂从沙发上迈出一步，却醉得一个趔趄，无力地摔倒在地板上。他又伤心又可怜，几乎无法自己站起来。他吸了吸鼻子，说了些言不由衷的怨恨的话。</p><p>Billy 伸出手，把他扶了起来（并不是马上）。然后他迅速拿起外套，背着手闷闷不乐地走了出去。</p><p>“去睡觉吧，马蒂。别担心我。</p><p><em>不要回头。只是不要回头。</em></p>]]></content>
      
      
      <categories>
          
          <category> Post </category>
          
      </categories>
      
      
        <tags>
            
            <tag> billymarty </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
